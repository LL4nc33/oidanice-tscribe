# WHY custom nginx config: Three responsibilities:
# 1. Serve React static files efficiently with caching
# 2. Proxy /api requests to the FastAPI backend
# 3. SPA fallback so client-side routing works on page refresh

server {
    listen 8080;
    server_name _;

    root /usr/share/nginx/html;
    index index.html;

    # WHY security headers: Prevent MIME-type sniffing attacks, block
    # clickjacking via iframes, and control referrer information leakage.
    add_header X-Content-Type-Options "nosniff" always;
    add_header X-Frame-Options "DENY" always;
    add_header Referrer-Policy "strict-origin-when-cross-origin" always;

    # WHY proxy_pass for /api/: Frontend and backend run in separate
    # containers. nginx forwards API calls to the backend service by
    # Docker Compose service name (http://api:8000).
    location /api/ {
        proxy_pass http://api:8000/api/;
        # WHY $http_host instead of $host: $http_host includes the port
        # number (e.g. 192.168.178.78:58008). Without the port, FastAPI's
        # redirect responses (307 trailing slash) generate URLs on port 80.
        proxy_set_header Host $http_host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;

        # WHY increased timeouts: Transcription job submission and
        # large file uploads can take longer than the default 60s.
        proxy_read_timeout 300s;
        proxy_send_timeout 300s;

        # WHY buffering off: Enables streaming responses (SSE/WebSocket)
        # for real-time progress updates from the backend.
        proxy_buffering off;
    }

    # WHY try_files with fallback: React Router uses client-side routing.
    # Without this, refreshing /jobs/abc123 would return 404 because nginx
    # looks for a literal /jobs/abc123 file. Falling back to index.html
    # lets React handle the route.
    location / {
        try_files $uri $uri/ /index.html;
    }

    # WHY cache static assets: JS/CSS bundles have content hashes in
    # filenames (e.g., main.a1b2c3.js), so they can be cached aggressively.
    # New deploys produce new filenames, busting the cache automatically.
    location ~* \.(js|css|png|jpg|jpeg|gif|ico|svg|woff|woff2)$ {
        expires 1y;
        add_header Cache-Control "public, immutable";
    }
}
